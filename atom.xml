<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>主标题测试</title>
  
  <subtitle>次级标题测试</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-03-16T15:00:52.075Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>作者测试</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>test</title>
    <link href="http://yoursite.com/2019/03/16/test/"/>
    <id>http://yoursite.com/2019/03/16/test/</id>
    <published>2019-03-16T12:48:43.000Z</published>
    <updated>2019-03-16T15:00:52.075Z</updated>
    
    <content type="html"><![CDATA[<h3 id="面试基础知识"><a href="#面试基础知识" class="headerlink" title="面试基础知识"></a>面试基础知识</h3><h4 id="传值和传引用的区别"><a href="#传值和传引用的区别" class="headerlink" title="传值和传引用的区别"></a>传值和传引用的区别</h4><p>传值：拷贝当前值<br>传引用：实质是传地址，使两个变量指向同一个地址，改变其中一个会联动改变（取消引用用unset()）<br>优缺点：按值传递时,php必须复制值。对于大型字符串和对象来说,这样做代价很大.（可挖坑‘对象是通过传引用’诱导！）<br><code>默认情况下对象是通过引用传递的</code>,这句话并<strong>不是完全正确</strong>的!!!</p><blockquote><p><a href="http://www.php.net/manual/zh/language.oop5.references.php" target="_blank" rel="noopener">当对象作为参数传递，作为结果返回，或者赋值给另外一个变量，另外一个变量跟原来的不是引用的关系，只是他们都保存着同一个标识符的拷贝，这个标识符指向同一个对象的真正内容</a></p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;;</span><br><span class="line">$a = <span class="keyword">new</span> A;</span><br><span class="line">$b = $a; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 此时$a,$b的关系：</span></span><br><span class="line"><span class="comment"> *        +-----------+      +-----------------+</span></span><br><span class="line"><span class="comment"> * $a --&gt; | object id | ---&gt; | object(Class A) |</span></span><br><span class="line"><span class="comment"> *        +-----------+      +-----------------+</span></span><br><span class="line"><span class="comment"> *                               ^</span></span><br><span class="line"><span class="comment"> *        +-----------+          |</span></span><br><span class="line"><span class="comment"> * $b --&gt; | object id | ---------+</span></span><br><span class="line"><span class="comment"> *        +-----------+    </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;;</span><br><span class="line">$a = <span class="keyword">new</span> A;</span><br><span class="line">$b = &amp;$a; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 此时$a,$b的关系：</span></span><br><span class="line"><span class="comment"> *        +-----------+      +-----------------+</span></span><br><span class="line"><span class="comment"> * $a --&gt; | object id | ---&gt; | object(Class A) |</span></span><br><span class="line"><span class="comment"> *        +-----------+      +-----------------+</span></span><br><span class="line"><span class="comment"> *             ^</span></span><br><span class="line"><span class="comment"> *             |</span></span><br><span class="line"><span class="comment"> * $b ---------+</span></span><br><span class="line"><span class="comment"> *           </span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>结论：对象传递一般不需要用传引用&amp;符号，因为传值的话只是拷贝一个标识符而已，代价不大。</p><h4 id="session和cookie"><a href="#session和cookie" class="headerlink" title="session和cookie"></a>session和cookie</h4><ul><li>生命周期：<br>.cookie:若不设置过期时间，则表示这个cookie的生命期为浏览器会话期间，关闭浏览器窗口，cookie就消失，会话cookie一般不存储在硬盘上而是保存在内存里；若设置了过期时间，浏览器就会把cookie保存到硬盘上，关闭后再次打开浏览器，这些cookie仍然有效直到超过设定的过期时间。<br>.session:session_gc工作：扫描所有生存时间超过gc_maxlifetime的session文件，并将其删除。<br>session_gc启动概率：<code>session.gc_probability/session.gc_divisor</code>(gc进程在每次session_start()都有概率启动)<br>由于SESSIONID的标识保存在客户端，且默认通过cookie发送，所以可以通过<code>session.cookie_lifetime</code>参数来设置cookie的过期时间，若过期，则客户端失去SESSIONID标识，即服务端对应的session文件已经是个垃圾文件。</li><li>sessionID传递流程（<strong>很重要，说明了禁用了cookie,session就不能用了</strong>）</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.第一次访问网站，服务端脚本开启了session_start();</span></span><br><span class="line"><span class="comment">//2.服务器会生成一个不重复的`session_id()`的文件；</span></span><br><span class="line"><span class="comment">//3.并将返回（Response）如下的HTTP头'Set-Cookie:PHPSESSIONID=xxxx';</span></span><br><span class="line"><span class="comment">//4.客户端接收到'Set-Cookie'的头，将'PHPSESSIONID'写入cookie；</span></span><br><span class="line"><span class="comment">//5.当你第二次访问该域名网站时，所有cookie会附带请求头（Request）发送给服务端；</span></span><br><span class="line"><span class="comment">//6.服务器识别'PHPSESSIONID'这个cookie，然后去session文件目录查找对应文件；</span></span><br><span class="line"><span class="comment">//7.若gc进程启动，将所有过期session文件清空，若果对应session文件没过期则读取文件，若过期找不到对应文件，则重新生成session文件</span></span><br></pre></td></tr></table></figure><ul><li>禁用cookie也能够使用session（<strong>但是基本session也废了也有暴露sessionid的危险，这种做法不可取</strong>）：使用其他机制以便在cookie被禁止时仍然能够把session id传递回服务器：比如：URL重写，就是把session id直接附加在URL路径的后面；或者用表单隐藏字段。（此时session的生命周期为：当前浏览会话所有可点击URL间传递，关闭浏览器重新请求网址则会重新生成session文件，<strong>因为PHPSESSIONID在第一次请求的时候根本无法带回客户端</strong>（隐患：不停生成session文件））</li><li><code>session_destroy()</code>:<strong>销毁当前会话的session文件，但不会重置当前会话所关联的全局变量， 也不会重置会话 cookie。</strong>（一般情况下并不需要调用session_destroy()函数，因为删除session文件有内部的回收机制）</li><li><code>session_unset()</code>:释放当前在内存中已经创建的所有$_SESSION变量，但不删除session文件以及不释放对应的sessionid</li><li>session共享：<br>原因：在默认情况下，各个服务器会各自分别对同一个客户端产生 SESSION ID<br>1）用redis，方式通过php.ini配置<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">session.save_handler = redis<span class="comment">#配置为redis</span></span><br><span class="line">session.save_path =<span class="string">"tcp://127.0.0.1:6379"</span><span class="comment">#如果redis设置了密码则：session.save_path = "tcp://redis服务地址:端口?auth=密码"该方案由于配置不支持多样化，只能用于用户少量时的应用。</span></span><br></pre></td></tr></table></figure></li></ul><p>2)nginx反向代理的ip_hash机制<br>3)php可以配置将session保存在数据库中，缺点：加大数据库IO，增加数据库负担<br>次要问题：网站存在不同的子域名，如：A.example.com;B.example.com;cookie<strong>不能跨域访问</strong>。<br>解决：配置<code>session.cookie_domain</code>参数，使其指向同一个主域名即可。</p><h4 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h4><p>数据结构(5种)：String,Hash,List,Set,Zset<br>List:是一个双向列表,可以<code>LPUSH</code>,<code>LPOP</code>,<code>RPUSH</code>,<code>RPOP</code><br>提供了两种持久化的方式：RDB(默认)和AOF（Append-only file）<br>持久化：把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失。</p><p><strong>缓存穿透</strong><br>指查一个根本不存在的数据,缓存层和存储层都不会命中,那么每一次查询都会直接去存储层查询,给后端系统造成压力,失去了缓存保护后端存储的意义.<br>解决办法:对查询结果为空的情况也做缓存,并设置较短的过期时间.</p><p><strong>缓存雪崩</strong><br>大量的key设置了相同的过期时间，导致在缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩<br>解决办法:可以给缓存设置过期时间时加上一个随机值时间，使得每个key的过期时间分布开来，不会集中在同一时刻失效</p><p><strong>缓存击穿</strong>(比较少见)<br>一个存在的key，在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到DB.<br>(详细解释:一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞,造成瞬时DB请求量大、压力骤增。)<br>解决办法:设置热点数据永远不过期。或加互斥锁(待了解)</p><h4 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h4><ul><li><p>源地址哈希法(<strong>一致性hash算法</strong>)：<br>1）相比一般的hash取模算法，如果此缓存系统扩展（比如：增加或减少redis服务器的数量），节点故障宕机等将会带来很高的代价。如规则由<code>hash(k)%10</code>变成<code>hash(k)%11</code>,则会找不到对应的存储服务器。所以这个时候大量的数据失效了.<br>2)步骤：将服务器的hash（服务器ip）值，将其配置到一个 0~2^n 的圆环上（n通常取32）；用同样的方法求出待存储对象的hash值，也将其配置到这个圆环上，然后从数据映射到的位置开始顺时针查找，将数据分布到找到的第一个服务器节点上；<br>3)缺点：雪崩效应：若一台服务器宕机，则数据由圆环上的下一个服务器节点承受。若承受不住，则造成雪崩。<br>4)解决雪崩效应办法：<strong>设置虚拟节点</strong>。对每个实际的节点，虚拟出多个虚拟节点.</p></li><li><p>轮询法:<br>将每一个请求轮流分配给服务器,不关心每台服务器的当前连接数和响应速度,这种算法适合所有服务器的处理性能都相同.</p></li><li><p>加权轮询法:<br>弥补了轮询法的不足,考虑每台服务器的处理能力,根据服务器的不同处理能力，给每个服务器分配不同的权值，使权值大的服务器能够处理更多的请求.</p></li><li><p>随机法<br>通过系统的随机算法,随机选一台服务器接收请求,其实际效果与轮询差不多</p></li><li><p>加权随机算法:<br>与加权轮询法一样,按照权重来随机请求后端服务器,而不是顺序</p></li><li><p>最小连接数法</p></li></ul><h4 id="nginx的负载均衡算法"><a href="#nginx的负载均衡算法" class="headerlink" title="nginx的负载均衡算法"></a>nginx的负载均衡算法</h4><p>采用upstream模块</p><blockquote><p>.down，表示当前的server暂时不参与负载均衡<br>.backup，预留的备份机器。当其他所有的非backup机器出现故障或者忙的时候，才会请求backup机器，因此这台机器的访问压力最低(无法与ip_hash配合使用)<br>.max_fails，允许请求失败的次数，默认为1。<br>.fail_timeout，默认10s。<br>(max_fails和fail_timeout 这两个参数是组合使用的，表示server 假如失败次数达到max_fails 次，并保持fail_timeout秒之内该服务器不能被访问)–这也是nginx判断该服务器是否down的标准</p></blockquote><ul><li><p>轮询(默认)</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> backserver &#123; </span><br><span class="line"><span class="attribute">server</span> <span class="number">192.168.1.14</span>; </span><br><span class="line"><span class="attribute">server</span> <span class="number">192.168.1.15</span>;</span><br><span class="line"><span class="attribute">server</span> <span class="number">192.168.1.16</span> down;<span class="comment">#暂时不参与负载</span></span><br><span class="line"><span class="attribute">server</span> <span class="number">192.168.1.17</span> backup;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>weight(加权轮询)</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> backserver &#123; </span><br><span class="line"><span class="attribute">server</span> <span class="number">192.168.1.14</span> weight=<span class="number">1</span>; </span><br><span class="line"><span class="attribute">server</span> <span class="number">192.168.1.15</span> weight=<span class="number">2</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>ip_hash</strong>(ip哈希)<br>通过客户端请求ip进行hash，再通过hash值选择后端server</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> backserver &#123; </span><br><span class="line">ip_hash; </span><br><span class="line"><span class="attribute">server</span> <span class="number">192.168.0.14</span>; </span><br><span class="line"><span class="attribute">server</span> <span class="number">192.168.0.15</span>;</span><br><span class="line"><span class="attribute">server</span> <span class="number">192.168.0.16</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>假如当前server不能提供服务，就会根据当前的哈希值再哈希出一个新哈希值，选择另一个服务器继续尝试.(所以应该是一致性哈希算法)当尝试次数达到20次，会转而使用轮循的方法.<br>ip_hash哈希原理:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">　　      hash[i+<span class="number">1</span>] = (hash[i] * <span class="number">113</span> + iphp-&gt;addr[i]) % <span class="number">6271</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有服务器暂时不使用,须其标记为“down”,而不是直接从配置文件中删除或注释掉.<br>(像上面的例子,注释掉一台,则会按2台服务器计算hash,使得原本所有的缓存信息可能失效;如果直接标记为down,nginx还是按3台服务器来进行hash,而未命中的缓存会进行再hash寻找下一台服务器)</p><p>优点:可以解决session问题<br>缺点:不均衡,因为每次请求都是固定的服务器,使得有可能某些承受过多或过少的请求.</p><ul><li><p>fair（第三方,知道就行）<br>按后端服务器的响应时间来分配请求，响应时间短的优先分配。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> backserver &#123; </span><br><span class="line"><span class="attribute">server</span> <span class="number">192.168.0.14</span>; </span><br><span class="line"><span class="attribute">server</span> <span class="number">192.168.0.15</span>;</span><br><span class="line">fair;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>url_hash（第三方,知道就行）<br>按请求url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为<strong>缓存</strong>时比较有效(同一个url–也就是同一个资源请求,会到达同一台机器，一旦缓存住了资源，再此收到请求，就可以从缓存中读取)。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> backserver &#123;  </span><br><span class="line">  <span class="attribute">server</span> <span class="number">192.168.0.14</span>;  </span><br><span class="line">  <span class="attribute">server</span> <span class="number">192.168.0.15</span>;  </span><br><span class="line">  <span class="attribute">hash</span> <span class="variable">$request_uri</span>;  </span><br><span class="line">  <span class="attribute">hash_method</span> crc32;<span class="comment">#使用crc32的hash方式  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><p>分隔符<br><code>/</code> <code>#</code> <code>~</code></p><blockquote><p>如果分隔符需要在模式内进行匹配，它必须使用反斜线进行转义。如果分隔符经常在 模式内出现， 一个更好的选择就是是用其他分隔符来提高可读性。</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$pattern = <span class="string">'/http:\/\/.*com/'</span>;<span class="comment">//需要转义/</span></span><br><span class="line">$pattern = <span class="string">'#http://.*com#'</span>;<span class="comment">//不需要转义</span></span><br></pre></td></tr></table></figure><p>元字符</p><table><thead><tr><th>元字符</th><th>描述</th><th>反义</th></tr></thead><tbody><tr><td><code>.</code></td><td>除换行符以外的任意字符</td><td></td></tr><tr><td><code>\w</code></td><td>字母或数字或下划线或汉字</td><td><code>\W</code></td></tr><tr><td><code>\s</code></td><td>任意空白符</td><td><code>\S</code></td></tr><tr><td><code>\d</code></td><td>数字</td><td><code>\D</code></td></tr><tr><td><code>\b</code></td><td>单词的开始或结束</td><td><code>\B</code></td></tr><tr><td><code>^</code></td><td>字符串的开始</td><td></td></tr><tr><td><code>$</code></td><td>字符串的结束</td><td></td></tr><tr><td><code>-</code></td><td>表示范围</td><td></td></tr><tr><td><code>[]</code></td><td>匹配括号中的任意一个字符</td><td></td></tr><tr><td><code>*</code> <code>+</code> <code>?</code></td><td>量词</td></tr></tbody></table><ul><li><p>贪婪模式：匹配尽可能多的字符<br>如字符串manaaaaan ,用<code>m.*n</code>将匹配到整个字符串，而不是man</p></li><li><p>懒惰模式：匹配尽可能少的字符<br>方式：加个<code>?</code>,用<code>m.*?n</code>将匹配到man</p></li></ul><p>量词</p><table><thead><tr><th>量词</th><th>描述</th><th>惰性匹配量词</th></tr></thead><tbody><tr><td><code>*</code></td><td>重复0次或更多次</td><td><code>*?</code></td></tr><tr><td><code>+</code></td><td>重复1次或更多次</td><td><code>+?</code></td></tr><tr><td><code>？</code></td><td>重复0次或1次</td><td><code>??</code></td></tr><tr><td><code>{n，}</code></td><td>重复n次或更多次</td><td><code>{n,}?</code></td></tr><tr><td><code>{n，m}</code></td><td>重复n次到m次</td><td><code>{n,m}?</code></td></tr></tbody></table><p>匹配手机号（笔试题）<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkPhone</span><span class="params">($number)</span></span>&#123;</span><br><span class="line">    $pattern = <span class="string">'#^1[3578]\d&#123;9&#125;#'</span>;<span class="comment">//重点理解</span></span><br><span class="line">    <span class="keyword">if</span>(!preg_match($pattern,$number))&#123;<span class="comment">//preg_match()返回匹配次数，找不到匹配时返回0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>匹配Email地址<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$pattern = <span class="string">'#(\w)+@(\w)+\.(\w)+#'</span>;<span class="comment">//简单的匹配username@domain.xxx的情况</span></span><br></pre></td></tr></table></figure></p><h4 id="字符串处理（笔试常出）"><a href="#字符串处理（笔试常出）" class="headerlink" title="字符串处理（笔试常出）"></a>字符串处理（笔试常出）</h4><h4 id="URL重写与搜索引擎优化（SEO）"><a href="#URL重写与搜索引擎优化（SEO）" class="headerlink" title="URL重写与搜索引擎优化（SEO）"></a>URL重写与搜索引擎优化（SEO）</h4><p><strong>URL重写（Rewrite）是截取传入web请求并自动将请求重定向到其他URL的过程</strong><br>两种实现方式：<br>.纯代码实现：通过解析PATH_INFO实现<br>.服务器实现：如利用Apache的mod_rewrite模块实现</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;面试基础知识&quot;&gt;&lt;a href=&quot;#面试基础知识&quot; class=&quot;headerlink&quot; title=&quot;面试基础知识&quot;&gt;&lt;/a&gt;面试基础知识&lt;/h3&gt;&lt;h4 id=&quot;传值和传引用的区别&quot;&gt;&lt;a href=&quot;#传值和传引用的区别&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="cate1" scheme="http://yoursite.com/categories/cate1/"/>
    
      <category term="cate2" scheme="http://yoursite.com/categories/cate1/cate2/"/>
    
    
      <category term="tag1" scheme="http://yoursite.com/tags/tag1/"/>
    
      <category term="tag2" scheme="http://yoursite.com/tags/tag2/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2018/11/05/hello-world/"/>
    <id>http://yoursite.com/2018/11/05/hello-world/</id>
    <published>2018-11-05T14:37:06.771Z</published>
    <updated>2018-11-05T14:37:06.781Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
