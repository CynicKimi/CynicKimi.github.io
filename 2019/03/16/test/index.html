<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>test | 主标题测试</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">test</h1><a id="logo" href="/.">主标题测试</a><p class="description">次级标题测试</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">test</h1><div class="post-meta">Mar 16, 2019<span> | </span><span class="category"><a href="/categories/cate1/">cate1</a><a href="/categories/cate1/cate2/">cate2</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><a class="disqus-comment-count" data-disqus-identifier="2019/03/16/test/" href="/2019/03/16/test/#disqus_thread"></a><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#面试基础知识"><span class="toc-number">1.</span> <span class="toc-text">面试基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#传值和传引用的区别"><span class="toc-number">1.1.</span> <span class="toc-text">传值和传引用的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#session和cookie"><span class="toc-number">1.2.</span> <span class="toc-text">session和cookie</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis"><span class="toc-number">1.3.</span> <span class="toc-text">Redis</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#负载均衡算法"><span class="toc-number">1.4.</span> <span class="toc-text">负载均衡算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#nginx的负载均衡算法"><span class="toc-number">1.5.</span> <span class="toc-text">nginx的负载均衡算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#正则表达式"><span class="toc-number">1.6.</span> <span class="toc-text">正则表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#字符串处理（笔试常出）"><span class="toc-number">1.7.</span> <span class="toc-text">字符串处理（笔试常出）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#URL重写与搜索引擎优化（SEO）"><span class="toc-number">1.8.</span> <span class="toc-text">URL重写与搜索引擎优化（SEO）</span></a></li></ol></li></ol></div></div><div class="post-content"><h3 id="面试基础知识"><a href="#面试基础知识" class="headerlink" title="面试基础知识"></a>面试基础知识</h3><h4 id="传值和传引用的区别"><a href="#传值和传引用的区别" class="headerlink" title="传值和传引用的区别"></a>传值和传引用的区别</h4><p>传值：拷贝当前值<br>传引用：实质是传地址，使两个变量指向同一个地址，改变其中一个会联动改变（取消引用用unset()）<br>优缺点：按值传递时,php必须复制值。对于大型字符串和对象来说,这样做代价很大.（可挖坑‘对象是通过传引用’诱导！）<br><code>默认情况下对象是通过引用传递的</code>,这句话并<strong>不是完全正确</strong>的!!!</p>
<blockquote>
<p><a href="http://www.php.net/manual/zh/language.oop5.references.php" target="_blank" rel="noopener">当对象作为参数传递，作为结果返回，或者赋值给另外一个变量，另外一个变量跟原来的不是引用的关系，只是他们都保存着同一个标识符的拷贝，这个标识符指向同一个对象的真正内容</a></p>
</blockquote>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;;</span><br><span class="line">$a = <span class="keyword">new</span> A;</span><br><span class="line">$b = $a; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 此时$a,$b的关系：</span></span><br><span class="line"><span class="comment"> *        +-----------+      +-----------------+</span></span><br><span class="line"><span class="comment"> * $a --&gt; | object id | ---&gt; | object(Class A) |</span></span><br><span class="line"><span class="comment"> *        +-----------+      +-----------------+</span></span><br><span class="line"><span class="comment"> *                               ^</span></span><br><span class="line"><span class="comment"> *        +-----------+          |</span></span><br><span class="line"><span class="comment"> * $b --&gt; | object id | ---------+</span></span><br><span class="line"><span class="comment"> *        +-----------+    </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;;</span><br><span class="line">$a = <span class="keyword">new</span> A;</span><br><span class="line">$b = &amp;$a; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 此时$a,$b的关系：</span></span><br><span class="line"><span class="comment"> *        +-----------+      +-----------------+</span></span><br><span class="line"><span class="comment"> * $a --&gt; | object id | ---&gt; | object(Class A) |</span></span><br><span class="line"><span class="comment"> *        +-----------+      +-----------------+</span></span><br><span class="line"><span class="comment"> *             ^</span></span><br><span class="line"><span class="comment"> *             |</span></span><br><span class="line"><span class="comment"> * $b ---------+</span></span><br><span class="line"><span class="comment"> *           </span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>结论：对象传递一般不需要用传引用&amp;符号，因为传值的话只是拷贝一个标识符而已，代价不大。</p>
<h4 id="session和cookie"><a href="#session和cookie" class="headerlink" title="session和cookie"></a>session和cookie</h4><ul>
<li>生命周期：<br>.cookie:若不设置过期时间，则表示这个cookie的生命期为浏览器会话期间，关闭浏览器窗口，cookie就消失，会话cookie一般不存储在硬盘上而是保存在内存里；若设置了过期时间，浏览器就会把cookie保存到硬盘上，关闭后再次打开浏览器，这些cookie仍然有效直到超过设定的过期时间。<br>.session:session_gc工作：扫描所有生存时间超过gc_maxlifetime的session文件，并将其删除。<br>session_gc启动概率：<code>session.gc_probability/session.gc_divisor</code>(gc进程在每次session_start()都有概率启动)<br>由于SESSIONID的标识保存在客户端，且默认通过cookie发送，所以可以通过<code>session.cookie_lifetime</code>参数来设置cookie的过期时间，若过期，则客户端失去SESSIONID标识，即服务端对应的session文件已经是个垃圾文件。</li>
<li>sessionID传递流程（<strong>很重要，说明了禁用了cookie,session就不能用了</strong>）</li>
</ul>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.第一次访问网站，服务端脚本开启了session_start();</span></span><br><span class="line"><span class="comment">//2.服务器会生成一个不重复的`session_id()`的文件；</span></span><br><span class="line"><span class="comment">//3.并将返回（Response）如下的HTTP头'Set-Cookie:PHPSESSIONID=xxxx';</span></span><br><span class="line"><span class="comment">//4.客户端接收到'Set-Cookie'的头，将'PHPSESSIONID'写入cookie；</span></span><br><span class="line"><span class="comment">//5.当你第二次访问该域名网站时，所有cookie会附带请求头（Request）发送给服务端；</span></span><br><span class="line"><span class="comment">//6.服务器识别'PHPSESSIONID'这个cookie，然后去session文件目录查找对应文件；</span></span><br><span class="line"><span class="comment">//7.若gc进程启动，将所有过期session文件清空，若果对应session文件没过期则读取文件，若过期找不到对应文件，则重新生成session文件</span></span><br></pre></td></tr></table></figure>
<ul>
<li>禁用cookie也能够使用session（<strong>但是基本session也废了也有暴露sessionid的危险，这种做法不可取</strong>）：使用其他机制以便在cookie被禁止时仍然能够把session id传递回服务器：比如：URL重写，就是把session id直接附加在URL路径的后面；或者用表单隐藏字段。（此时session的生命周期为：当前浏览会话所有可点击URL间传递，关闭浏览器重新请求网址则会重新生成session文件，<strong>因为PHPSESSIONID在第一次请求的时候根本无法带回客户端</strong>（隐患：不停生成session文件））</li>
<li><code>session_destroy()</code>:<strong>销毁当前会话的session文件，但不会重置当前会话所关联的全局变量， 也不会重置会话 cookie。</strong>（一般情况下并不需要调用session_destroy()函数，因为删除session文件有内部的回收机制）</li>
<li><code>session_unset()</code>:释放当前在内存中已经创建的所有$_SESSION变量，但不删除session文件以及不释放对应的sessionid</li>
<li>session共享：<br>原因：在默认情况下，各个服务器会各自分别对同一个客户端产生 SESSION ID<br>1）用redis，方式通过php.ini配置<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">session.save_handler = redis<span class="comment">#配置为redis</span></span><br><span class="line">session.save_path =<span class="string">"tcp://127.0.0.1:6379"</span><span class="comment">#如果redis设置了密码则：session.save_path = "tcp://redis服务地址:端口?auth=密码"该方案由于配置不支持多样化，只能用于用户少量时的应用。</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>2)nginx反向代理的ip_hash机制<br>3)php可以配置将session保存在数据库中，缺点：加大数据库IO，增加数据库负担<br>次要问题：网站存在不同的子域名，如：A.example.com;B.example.com;cookie<strong>不能跨域访问</strong>。<br>解决：配置<code>session.cookie_domain</code>参数，使其指向同一个主域名即可。</p>
<h4 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h4><p>数据结构(5种)：String,Hash,List,Set,Zset<br>List:是一个双向列表,可以<code>LPUSH</code>,<code>LPOP</code>,<code>RPUSH</code>,<code>RPOP</code><br>提供了两种持久化的方式：RDB(默认)和AOF（Append-only file）<br>持久化：把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失。</p>
<p><strong>缓存穿透</strong><br>指查一个根本不存在的数据,缓存层和存储层都不会命中,那么每一次查询都会直接去存储层查询,给后端系统造成压力,失去了缓存保护后端存储的意义.<br>解决办法:对查询结果为空的情况也做缓存,并设置较短的过期时间.</p>
<p><strong>缓存雪崩</strong><br>大量的key设置了相同的过期时间，导致在缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩<br>解决办法:可以给缓存设置过期时间时加上一个随机值时间，使得每个key的过期时间分布开来，不会集中在同一时刻失效</p>
<p><strong>缓存击穿</strong>(比较少见)<br>一个存在的key，在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到DB.<br>(详细解释:一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞,造成瞬时DB请求量大、压力骤增。)<br>解决办法:设置热点数据永远不过期。或加互斥锁(待了解)</p>
<h4 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h4><ul>
<li><p>源地址哈希法(<strong>一致性hash算法</strong>)：<br>1）相比一般的hash取模算法，如果此缓存系统扩展（比如：增加或减少redis服务器的数量），节点故障宕机等将会带来很高的代价。如规则由<code>hash(k)%10</code>变成<code>hash(k)%11</code>,则会找不到对应的存储服务器。所以这个时候大量的数据失效了.<br>2)步骤：将服务器的hash（服务器ip）值，将其配置到一个 0~2^n 的圆环上（n通常取32）；用同样的方法求出待存储对象的hash值，也将其配置到这个圆环上，然后从数据映射到的位置开始顺时针查找，将数据分布到找到的第一个服务器节点上；<br>3)缺点：雪崩效应：若一台服务器宕机，则数据由圆环上的下一个服务器节点承受。若承受不住，则造成雪崩。<br>4)解决雪崩效应办法：<strong>设置虚拟节点</strong>。对每个实际的节点，虚拟出多个虚拟节点.</p>
</li>
<li><p>轮询法:<br>将每一个请求轮流分配给服务器,不关心每台服务器的当前连接数和响应速度,这种算法适合所有服务器的处理性能都相同.</p>
</li>
<li><p>加权轮询法:<br>弥补了轮询法的不足,考虑每台服务器的处理能力,根据服务器的不同处理能力，给每个服务器分配不同的权值，使权值大的服务器能够处理更多的请求.</p>
</li>
<li><p>随机法<br>通过系统的随机算法,随机选一台服务器接收请求,其实际效果与轮询差不多</p>
</li>
<li><p>加权随机算法:<br>与加权轮询法一样,按照权重来随机请求后端服务器,而不是顺序</p>
</li>
<li><p>最小连接数法</p>
</li>
</ul>
<h4 id="nginx的负载均衡算法"><a href="#nginx的负载均衡算法" class="headerlink" title="nginx的负载均衡算法"></a>nginx的负载均衡算法</h4><p>采用upstream模块</p>
<blockquote>
<p>.down，表示当前的server暂时不参与负载均衡<br>.backup，预留的备份机器。当其他所有的非backup机器出现故障或者忙的时候，才会请求backup机器，因此这台机器的访问压力最低(无法与ip_hash配合使用)<br>.max_fails，允许请求失败的次数，默认为1。<br>.fail_timeout，默认10s。<br>(max_fails和fail_timeout 这两个参数是组合使用的，表示server 假如失败次数达到max_fails 次，并保持fail_timeout秒之内该服务器不能被访问)–这也是nginx判断该服务器是否down的标准</p>
</blockquote>
<ul>
<li><p>轮询(默认)</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> backserver &#123; </span><br><span class="line"><span class="attribute">server</span> <span class="number">192.168.1.14</span>; </span><br><span class="line"><span class="attribute">server</span> <span class="number">192.168.1.15</span>;</span><br><span class="line"><span class="attribute">server</span> <span class="number">192.168.1.16</span> down;<span class="comment">#暂时不参与负载</span></span><br><span class="line"><span class="attribute">server</span> <span class="number">192.168.1.17</span> backup;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>weight(加权轮询)</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> backserver &#123; </span><br><span class="line"><span class="attribute">server</span> <span class="number">192.168.1.14</span> weight=<span class="number">1</span>; </span><br><span class="line"><span class="attribute">server</span> <span class="number">192.168.1.15</span> weight=<span class="number">2</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>ip_hash</strong>(ip哈希)<br>通过客户端请求ip进行hash，再通过hash值选择后端server</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> backserver &#123; </span><br><span class="line">ip_hash; </span><br><span class="line"><span class="attribute">server</span> <span class="number">192.168.0.14</span>; </span><br><span class="line"><span class="attribute">server</span> <span class="number">192.168.0.15</span>;</span><br><span class="line"><span class="attribute">server</span> <span class="number">192.168.0.16</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>假如当前server不能提供服务，就会根据当前的哈希值再哈希出一个新哈希值，选择另一个服务器继续尝试.(所以应该是一致性哈希算法)当尝试次数达到20次，会转而使用轮循的方法.<br>ip_hash哈希原理:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">　　      hash[i+<span class="number">1</span>] = (hash[i] * <span class="number">113</span> + iphp-&gt;addr[i]) % <span class="number">6271</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果有服务器暂时不使用,须其标记为“down”,而不是直接从配置文件中删除或注释掉.<br>(像上面的例子,注释掉一台,则会按2台服务器计算hash,使得原本所有的缓存信息可能失效;如果直接标记为down,nginx还是按3台服务器来进行hash,而未命中的缓存会进行再hash寻找下一台服务器)</p>
<p>优点:可以解决session问题<br>缺点:不均衡,因为每次请求都是固定的服务器,使得有可能某些承受过多或过少的请求.</p>
<ul>
<li><p>fair（第三方,知道就行）<br>按后端服务器的响应时间来分配请求，响应时间短的优先分配。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> backserver &#123; </span><br><span class="line"><span class="attribute">server</span> <span class="number">192.168.0.14</span>; </span><br><span class="line"><span class="attribute">server</span> <span class="number">192.168.0.15</span>;</span><br><span class="line">fair;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>url_hash（第三方,知道就行）<br>按请求url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为<strong>缓存</strong>时比较有效(同一个url–也就是同一个资源请求,会到达同一台机器，一旦缓存住了资源，再此收到请求，就可以从缓存中读取)。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> backserver &#123;  </span><br><span class="line">  <span class="attribute">server</span> <span class="number">192.168.0.14</span>;  </span><br><span class="line">  <span class="attribute">server</span> <span class="number">192.168.0.15</span>;  </span><br><span class="line">  <span class="attribute">hash</span> <span class="variable">$request_uri</span>;  </span><br><span class="line">  <span class="attribute">hash_method</span> crc32;<span class="comment">#使用crc32的hash方式  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><p>分隔符<br><code>/</code> <code>#</code> <code>~</code></p>
<blockquote>
<p>如果分隔符需要在模式内进行匹配，它必须使用反斜线进行转义。如果分隔符经常在 模式内出现， 一个更好的选择就是是用其他分隔符来提高可读性。</p>
</blockquote>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$pattern = <span class="string">'/http:\/\/.*com/'</span>;<span class="comment">//需要转义/</span></span><br><span class="line">$pattern = <span class="string">'#http://.*com#'</span>;<span class="comment">//不需要转义</span></span><br></pre></td></tr></table></figure>
<p>元字符</p>
<table>
<thead>
<tr>
<th>元字符</th>
<th>描述</th>
<th>反义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>.</code></td>
<td>除换行符以外的任意字符</td>
<td></td>
</tr>
<tr>
<td><code>\w</code></td>
<td>字母或数字或下划线或汉字</td>
<td><code>\W</code></td>
</tr>
<tr>
<td><code>\s</code></td>
<td>任意空白符</td>
<td><code>\S</code></td>
</tr>
<tr>
<td><code>\d</code></td>
<td>数字</td>
<td><code>\D</code></td>
</tr>
<tr>
<td><code>\b</code></td>
<td>单词的开始或结束</td>
<td><code>\B</code></td>
</tr>
<tr>
<td><code>^</code></td>
<td>字符串的开始</td>
<td></td>
</tr>
<tr>
<td><code>$</code></td>
<td>字符串的结束</td>
<td></td>
</tr>
<tr>
<td><code>-</code></td>
<td>表示范围</td>
<td></td>
</tr>
<tr>
<td><code>[]</code></td>
<td>匹配括号中的任意一个字符</td>
<td></td>
</tr>
<tr>
<td><code>*</code> <code>+</code> <code>?</code></td>
<td>量词</td>
</tr>
</tbody>
</table>
<ul>
<li><p>贪婪模式：匹配尽可能多的字符<br>如字符串manaaaaan ,用<code>m.*n</code>将匹配到整个字符串，而不是man</p>
</li>
<li><p>懒惰模式：匹配尽可能少的字符<br>方式：加个<code>?</code>,用<code>m.*?n</code>将匹配到man</p>
</li>
</ul>
<p>量词</p>
<table>
<thead>
<tr>
<th>量词</th>
<th>描述</th>
<th>惰性匹配量词</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>*</code></td>
<td>重复0次或更多次</td>
<td><code>*?</code></td>
</tr>
<tr>
<td><code>+</code></td>
<td>重复1次或更多次</td>
<td><code>+?</code></td>
</tr>
<tr>
<td><code>？</code></td>
<td>重复0次或1次</td>
<td><code>??</code></td>
</tr>
<tr>
<td><code>{n，}</code></td>
<td>重复n次或更多次</td>
<td><code>{n,}?</code></td>
</tr>
<tr>
<td><code>{n，m}</code></td>
<td>重复n次到m次</td>
<td><code>{n,m}?</code></td>
</tr>
</tbody>
</table>
<p>匹配手机号（笔试题）<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkPhone</span><span class="params">($number)</span></span>&#123;</span><br><span class="line">    $pattern = <span class="string">'#^1[3578]\d&#123;9&#125;#'</span>;<span class="comment">//重点理解</span></span><br><span class="line">    <span class="keyword">if</span>(!preg_match($pattern,$number))&#123;<span class="comment">//preg_match()返回匹配次数，找不到匹配时返回0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>匹配Email地址<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$pattern = <span class="string">'#(\w)+@(\w)+\.(\w)+#'</span>;<span class="comment">//简单的匹配username@domain.xxx的情况</span></span><br></pre></td></tr></table></figure></p>
<h4 id="字符串处理（笔试常出）"><a href="#字符串处理（笔试常出）" class="headerlink" title="字符串处理（笔试常出）"></a>字符串处理（笔试常出）</h4><h4 id="URL重写与搜索引擎优化（SEO）"><a href="#URL重写与搜索引擎优化（SEO）" class="headerlink" title="URL重写与搜索引擎优化（SEO）"></a>URL重写与搜索引擎优化（SEO）</h4><p><strong>URL重写（Rewrite）是截取传入web请求并自动将请求重定向到其他URL的过程</strong><br>两种实现方式：<br>.纯代码实现：通过解析PATH_INFO实现<br>.服务器实现：如利用Apache的mod_rewrite模块实现</p>
</div><div class="tags"><a href="/tags/tag1/">tag1</a><a href="/tags/tag2/">tag2</a></div><div class="post-nav"><a class="next" href="/2018/11/05/hello-world/">Hello World</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论（请确保 Disqus 可以正常加载）</button></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'http://yoursite.com/2019/03/16/test/';
    this.page.identifier = '2019/03/16/test/';
    this.page.title = 'test';
  };</script><script type="text/javascript" id="disqus-lazy-load-script">$.ajax({
url: 'https://disqus.com/next/config.json',
timeout: 2500,
type: 'GET',
success: function(){
  var d = document;
  var s = d.createElement('script');
  s.src = '//cynickimi.disqus.com/embed.js';
  s.setAttribute('data-timestamp', + new Date());
  (d.head || d.body).appendChild(s);
  $('.disqus_click_btn').css('display', 'none');
},
error: function() {
  $('.disqus_click_btn').css('display', 'block');
}
});</script><script type="text/javascript" id="disqus-click-load">$('.btn_click_load').click(() => {  //click to load comments
    (() => { // DON'T EDIT BELOW THIS LINE
        var d = document;
        var s = d.createElement('script');
        s.src = '//cynickimi.disqus.com/embed.js';
        s.setAttribute('data-timestamp', + new Date());
        (d.head || d.body).appendChild(s);
    })();
    $('.disqus_click_btn').css('display','none');
});</script><script type="text/javascript" id="disqus-count-script">$(function() {
     var xhr = new XMLHttpRequest();
     xhr.open('GET', '//disqus.com/next/config.json', true);
     xhr.timeout = 2500;
     xhr.onreadystatechange = function () {
       if (xhr.readyState === 4 && xhr.status === 200) {
         $('.post-meta .post-comments-count').show();
         var s = document.createElement('script');
         s.id = 'dsq-count-scr';
         s.src = 'https://cynickimi.disqus.com/count.js';
         s.async = true;
         (document.head || document.body).appendChild(s);
       }
     };
     xhr.ontimeout = function () { xhr.abort(); };
     xhr.send(null);
   });
</script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://yoursite.com"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/cate1/">cate1</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/cate1/cate2/">cate2</a><span class="category-list-count">1</span></li></ul></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/tag1/" style="font-size: 15px;">tag1</a> <a href="/tags/tag2/" style="font-size: 15px;">tag2</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/03/16/test/">test</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/05/hello-world/">Hello World</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//cynickimi.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">主标题测试.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>